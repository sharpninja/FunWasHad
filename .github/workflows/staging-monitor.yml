name: Monitor Staging Workflow

on:
  workflow_run:
    workflows: ["Staging Actions"]
    types: [completed]
    branches: [develop]

permissions:
  contents: write
  actions: read

jobs:
  update_status:
    name: Update Staging Status Document
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion != 'cancelled'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: develop
          fetch-depth: 1

      - name: Fetch workflow run details
        id: fetch_details
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Note: GITHUB_TOKEN has a rate limit of 1,000 requests per hour per repository.
          # For workflows with many jobs, consider implementing retry logic if rate limiting occurs.
        run: |
          RUN_ID="${{ github.event.workflow_run.id }}"
          REPO="${{ github.repository }}"
          
          echo "Fetching details for workflow run $RUN_ID"
          
          # Get workflow run details with error handling
          if ! gh api "/repos/$REPO/actions/runs/$RUN_ID" > /tmp/workflow_run.json 2>&1; then
            echo "Error: Failed to fetch workflow run details"
            exit 1
          fi
          
          # Verify workflow_run.json is valid JSON
          if ! jq empty /tmp/workflow_run.json 2>/dev/null; then
            echo "Error: Invalid JSON in workflow run response"
            exit 1
          fi
          
          # Get all jobs for this run with error handling
          if ! gh api "/repos/$REPO/actions/runs/$RUN_ID/jobs" --paginate > /tmp/jobs.json 2>&1; then
            echo "Error: Failed to fetch jobs data"
            exit 1
          fi
          
          # Verify jobs.json is valid JSON
          if ! jq empty /tmp/jobs.json 2>/dev/null; then
            echo "Error: Invalid JSON in jobs response"
            exit 1
          fi
          
          echo "Details fetched successfully"

      - name: Generate status document
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RUN_ID="${{ github.event.workflow_run.id }}"
          REPO="${{ github.repository }}"
          
          # Read workflow run details
          RUN_URL=$(jq -r '.html_url' /tmp/workflow_run.json)
          RUN_CONCLUSION=$(jq -r '.conclusion' /tmp/workflow_run.json)
          RUN_NUMBER=$(jq -r '.run_number' /tmp/workflow_run.json)
          CREATED_AT=$(jq -r '.created_at' /tmp/workflow_run.json)
          UPDATED_AT=$(jq -r '.updated_at' /tmp/workflow_run.json)
          HEAD_SHA=$(jq -r '.head_sha' /tmp/workflow_run.json)
          HEAD_BRANCH=$(jq -r '.head_branch' /tmp/workflow_run.json)
          
          # Sanitize variables to prevent markdown injection
          # Replace special markdown characters with escaped versions
          sanitize() {
            echo "$1" | sed 's/[`*_{}[\]()#+\-\.!|\\]/\\&/g'
          }
          
          SAFE_BRANCH=$(sanitize "$HEAD_BRANCH")
          SAFE_CONCLUSION=$(sanitize "$RUN_CONCLUSION")
          
          # Start building the status document
          cat > /tmp/staging-status.md << 'HEADER'
          # Staging Workflow Status
          
          This document is automatically generated and updated by the monitoring workflow.
          It shows the status of the most recent staging.yml workflow run on the develop branch.
          
          HEADER
          
          cat >> /tmp/staging-status.md << EOF
          ## Latest Run Information
          
          - **Run Number**: #$RUN_NUMBER
          - **Run ID**: $RUN_ID
          - **Status**: $SAFE_CONCLUSION
          - **Branch**: $SAFE_BRANCH
          - **Commit**: [\`${HEAD_SHA:0:7}\`](https://github.com/$REPO/commit/$HEAD_SHA)
          - **Started**: $CREATED_AT
          - **Completed**: $UPDATED_AT
          - **Run URL**: [View on GitHub]($RUN_URL)
          
          ---
          
          ## Job Status Summary
          
          EOF
          
          # Parse jobs and create status table
          echo "| Job Name | Status | Duration | Conclusion |" >> /tmp/staging-status.md
          echo "|----------|--------|----------|------------|" >> /tmp/staging-status.md
          
          jq -r '.jobs[] | "| \(.name) | \(.status) | \(if .started_at and .completed_at then ((.completed_at | fromdateiso8601) - (.started_at | fromdateiso8601) | tostring + "s") else "N/A" end) | \(.conclusion // "N/A") |"' /tmp/jobs.json >> /tmp/staging-status.md
          
          echo "" >> /tmp/staging-status.md
          echo "---" >> /tmp/staging-status.md
          echo "" >> /tmp/staging-status.md
          
          # Detailed job information with steps
          echo "## Detailed Job Information" >> /tmp/staging-status.md
          echo "" >> /tmp/staging-status.md
          
          # Get the job count
          JOB_COUNT=$(jq '.jobs | length' /tmp/jobs.json)
          
          # Validate JOB_COUNT is a number and greater than 0
          if ! [[ "$JOB_COUNT" =~ ^[0-9]+$ ]] || [ "$JOB_COUNT" -eq 0 ]; then
            echo "No jobs found or invalid job count"
          else
            for i in $(seq 0 $(($JOB_COUNT - 1))); do
            JOB_NAME=$(jq -r ".jobs[$i].name" /tmp/jobs.json)
            JOB_STATUS=$(jq -r ".jobs[$i].status" /tmp/jobs.json)
            JOB_CONCLUSION=$(jq -r ".jobs[$i].conclusion // \"N/A\"" /tmp/jobs.json)
            JOB_ID=$(jq -r ".jobs[$i].id" /tmp/jobs.json)
            JOB_URL=$(jq -r ".jobs[$i].html_url" /tmp/jobs.json)
            
            # Sanitize job name for markdown
            SAFE_JOB_NAME=$(echo "$JOB_NAME" | sed 's/[`*_{}[\]()#+\-\.!|\\]/\\&/g')
            
            echo "### $SAFE_JOB_NAME" >> /tmp/staging-status.md
            echo "" >> /tmp/staging-status.md
            echo "- **Status**: $JOB_STATUS" >> /tmp/staging-status.md
            echo "- **Conclusion**: $JOB_CONCLUSION" >> /tmp/staging-status.md
            echo "- **Job ID**: [\`$JOB_ID\`]($JOB_URL)" >> /tmp/staging-status.md
            echo "" >> /tmp/staging-status.md
            
            # Get step count for this job
            STEP_COUNT=$(jq ".jobs[$i].steps | length" /tmp/jobs.json)
            
            # Validate STEP_COUNT is a number before comparison
            if [[ "$STEP_COUNT" =~ ^[0-9]+$ ]] && [ "$STEP_COUNT" -gt 0 ]; then
              echo "#### Steps:" >> /tmp/staging-status.md
              echo "" >> /tmp/staging-status.md
              echo "| Step | Status | Conclusion |" >> /tmp/staging-status.md
              echo "|------|--------|------------|" >> /tmp/staging-status.md
              
              for j in $(seq 0 $(($STEP_COUNT - 1))); do
                STEP_NAME=$(jq -r ".jobs[$i].steps[$j].name" /tmp/jobs.json)
                STEP_STATUS=$(jq -r ".jobs[$i].steps[$j].status" /tmp/jobs.json)
                STEP_CONCLUSION=$(jq -r ".jobs[$i].steps[$j].conclusion // \"N/A\"" /tmp/jobs.json)
                # Sanitize step name for markdown table
                SAFE_STEP_NAME=$(echo "$STEP_NAME" | sed 's/[|]/\\|/g')
                echo "| $SAFE_STEP_NAME | $STEP_STATUS | $STEP_CONCLUSION |" >> /tmp/staging-status.md
              done
              
              echo "" >> /tmp/staging-status.md
            fi
            
            echo "" >> /tmp/staging-status.md
          done
          fi
          
          echo "---" >> /tmp/staging-status.md
          echo "" >> /tmp/staging-status.md

      - name: Collect build and deployment errors
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RUN_ID="${{ github.event.workflow_run.id }}"
          REPO="${{ github.repository }}"
          
          echo "## Build and Deployment Errors" >> /tmp/staging-status.md
          echo "" >> /tmp/staging-status.md
          
          # Find jobs that failed
          FAILED_JOBS=$(jq -r '.jobs[] | select(.conclusion == "failure") | .id' /tmp/jobs.json)
          
          if [ -z "$FAILED_JOBS" ]; then
            echo "✅ No build or deployment errors detected in this run." >> /tmp/staging-status.md
            echo "" >> /tmp/staging-status.md
          else
            for JOB_ID in $FAILED_JOBS; do
              JOB_NAME=$(jq -r ".jobs[] | select(.id == $JOB_ID) | .name" /tmp/jobs.json)
              echo "### Failed Job: $JOB_NAME" >> /tmp/staging-status.md
              echo "" >> /tmp/staging-status.md
              
              # Get job logs
              echo "Fetching logs for job $JOB_ID..."
              gh api "/repos/$REPO/actions/jobs/$JOB_ID/logs" > "/tmp/job_${JOB_ID}_logs.txt" 2>&1 || echo "Could not fetch logs for job $JOB_ID"
              
              if [ -f "/tmp/job_${JOB_ID}_logs.txt" ]; then
                # Extract error messages (look for common error patterns)
                ERROR_PATTERNS="error|Error|ERROR|failed|Failed|FAILED|exception|Exception"
                
                echo '<details>' >> /tmp/staging-status.md
                echo '<summary>View Error Log Excerpt</summary>' >> /tmp/staging-status.md
                echo '' >> /tmp/staging-status.md
                echo '```' >> /tmp/staging-status.md
                grep -iE "$ERROR_PATTERNS" "/tmp/job_${JOB_ID}_logs.txt" | head -50 >> /tmp/staging-status.md 2>/dev/null || echo "No specific error patterns found in logs" >> /tmp/staging-status.md
                echo '```' >> /tmp/staging-status.md
                echo '</details>' >> /tmp/staging-status.md
                echo '' >> /tmp/staging-status.md
              fi
            done
          fi
          
          echo "---" >> /tmp/staging-status.md
          echo "" >> /tmp/staging-status.md

      - name: Extract analyzer warnings
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RUN_ID="${{ github.event.workflow_run.id }}"
          REPO="${{ github.repository }}"
          
          echo "## Analyzer Warnings" >> /tmp/staging-status.md
          echo "" >> /tmp/staging-status.md
          
          # Get all job IDs
          ALL_JOBS=$(jq -r '.jobs[].id' /tmp/jobs.json)
          
          # Create a temporary file to collect all warnings
          > /tmp/all_warnings.txt
          
          for JOB_ID in $ALL_JOBS; do
            # Fetch logs if not already fetched
            if [ ! -f "/tmp/job_${JOB_ID}_logs.txt" ]; then
              echo "Fetching logs for job $JOB_ID..."
              gh api "/repos/$REPO/actions/jobs/$JOB_ID/logs" > "/tmp/job_${JOB_ID}_logs.txt" 2>&1 || continue
            fi
            
            if [ -f "/tmp/job_${JOB_ID}_logs.txt" ]; then
              # Extract analyzer warnings (CS, CA codes) with flexible pattern
              grep -oE '(CS|CA)[0-9]{4}[[:space:]]*:.*' "/tmp/job_${JOB_ID}_logs.txt" >> /tmp/all_warnings.txt 2>/dev/null || true
            fi
          done
          
          if [ -s /tmp/all_warnings.txt ]; then
            # Parse and aggregate warnings
            # Create a temporary file for processing
            > /tmp/warning_summary.txt
            
            # Extract warning codes and descriptions
            while IFS= read -r line; do
              # Extract warning code (CS#### or CA####)
              CODE=$(echo "$line" | grep -oE '(CS|CA)[0-9]{4}' | head -1)
              # Extract description (everything after the code and colon) and limit to 100 chars for processing
              DESC=$(echo "$line" | sed -E 's/.*(CS|CA)[0-9]{4}[[:space:]]*:[[:space:]]*//' | head -c 100)
              
              if [ -n "$CODE" ]; then
                echo "$CODE|$DESC" >> /tmp/warning_summary.txt
              fi
            done < /tmp/all_warnings.txt
            
            # Count occurrences and create table
            if [ -s /tmp/warning_summary.txt ]; then
              echo "| Warning Code | Count | Description |" >> /tmp/staging-status.md
              echo "|--------------|-------|-------------|" >> /tmp/staging-status.md
              
              # Extract codes, count them, then get sample descriptions
              # First, count warning codes
              cut -d'|' -f1 /tmp/warning_summary.txt | sort | uniq -c | sort -rn > /tmp/warning_counts.txt
              
              # For each unique code, get count and a sample description
              while read -r count code; do
                # Get first description for this code (limit to 80 chars for display)
                DESC=$(grep "^$code|" /tmp/warning_summary.txt | head -1 | cut -d'|' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | head -c 80)
                echo "| $code | $count | $DESC |" >> /tmp/staging-status.md
              done < /tmp/warning_counts.txt
              
              echo "" >> /tmp/staging-status.md
            else
              echo "✅ No analyzer warnings detected in this run." >> /tmp/staging-status.md
              echo "" >> /tmp/staging-status.md
            fi
          else
            echo "✅ No analyzer warnings detected in this run." >> /tmp/staging-status.md
            echo "" >> /tmp/staging-status.md
          fi
          
          echo "---" >> /tmp/staging-status.md
          echo "" >> /tmp/staging-status.md
          
          # Add footer with generation timestamp
          echo "" >> /tmp/staging-status.md
          echo "*Last updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')*" >> /tmp/staging-status.md

      - name: Update status document in repository
        run: |
          # Copy the generated status to docs folder
          mkdir -p docs
          cp /tmp/staging-status.md docs/STAGING-STATUS.md
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add and commit the file
          git add docs/STAGING-STATUS.md
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: update staging workflow status [skip ci]"
            
            # Push with error handling
            if git push origin develop; then
              echo "Status document updated successfully"
            else
              echo "Error: Failed to push status document update"
              echo "This could be due to:"
              echo "  - Branch protection rules"
              echo "  - Merge conflicts"
              echo "  - Network issues"
              echo "  - Insufficient permissions"
              exit 1
            fi
          fi
